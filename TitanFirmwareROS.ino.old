

#include "common.h"



void SendMotorPacket(char addr, char cmd, char data) 
{ 
  SabertoothSerial.write(addr);   
  SabertoothSerial.write(cmd);   
  SabertoothSerial.write(data); 
  SabertoothSerial.write((addr + cmd + data) & 127); 
} 

// number of days since 2000/01/01, valid for 2001..2099
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
    if (y >= 2000)
        y -= 2000;
    uint16_t days = d;
    for (uint8_t i = 1; i < m; ++i)
        days += pgm_read_byte(daysInMonth + i - 1);
    if (m > 2 && y % 4 == 0)
        ++days;
    return days + 365 * y + (y + 3) / 4 - 1;
}

static long time2long(uint16_t days, uint8_t h, uint8_t m, uint8_t s) {
    return ((days * 24L + h) * 60 + m) * 60 + s;
}



void InitializeIMU()
{
  if(!bno.begin())
  {

  }

  delay(1000);
 
  bno.setExtCrystalUse(true);
}


void InitializeGPS()
{
  GPS.begin(115200);
  //GPS.sendCommand(PMTK_SET_BAUD_115200);
  GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);
  
  GPS.sendCommand(PMTK_SET_NMEA_UPDATE_10HZ); // 1 Hz update rate
  GPS.sendCommand(PMTK_API_SET_FIX_CTL_5HZ);
  GPS.sendCommand(PGCMD_ANTENNA);

  delay(1000);
}

void publishTimeReference()
{
  gpstime.source = gps;
  uint32_t t;
  uint16_t days = date2days(GPS.year, GPS.month, GPS.day);
  t = time2long(days, GPS.hour, GPS.minute, GPS.seconds);
  t += SECONDS_FROM_1970_TO_2000;  // seconds from 1970 to 2000
  double d = (double)t;// + GPS.milliseconds / 1000.0;
  epochtime.fromSec(d);
  gpstime.time_ref = epochtime;
  pubTimeReference.publish(&gpstime);
}

void publishNavData()
{
  navData.header.frame_id = gps;
  navData.header.stamp = nh.now();
  navData.status.status =  -1;
  if (GPS.fix)
    navData.status.status =  1;
  navData.status.service = 1;
  navData.latitude = GPS.latitude;
  navData.longitude = GPS.longitude;
  navData.altitude = GPS.altitude;
  navData.position_covariance_type = 0;
  pubNavData.publish(&navData);
}

void publishNavVel()
{
  navVel.header.frame_id = gps;
  navVel.header.stamp = nh.now();
  navVel.twist.linear.x = float(GPS.speed*0.514444444444*sin(GPS.angle * 3.14/180.0));
  navVel.twist.linear.y = float(GPS.speed*0.514444444444*cos(GPS.angle * 3.14/180.0));
  pubNavVel.publish(&navVel); 
}

void publishGPS()
{
  GPS.readall();
  
  //if (c) BlueToothSerial.print(c);
  if (GPS.newNMEAreceived()) 
  {
    if (!GPS.parse(GPS.lastNMEA())) // this also sets the newNMEAreceived() flag to false
        return; 
        
    publishTimeReference();
    publishNavData();
    publishNavVel();

    
  }
  
}

void publishEncoders()
{
  long countLeft = -encoderLR.read();
  long countRight = encoderRR.read();
  lwheelData.data = countLeft;
  rwheelData.data = countRight;

  pubLWheel.publish(&lwheelData);
  pubRWheel.publish(&rwheelData);
}

void setLeftMotorPower(float power)
{
  if (power > 100.0)
    power = 100.0;
    
  if (power < -100.0)
    power = -100.0;
    
  char val = map(abs(power), 0, 100, 0, 127); 
  if (power >= 0.0)
  {
    SendMotorPacket(SABERTOOTH_ADDR, SABERTOOTH_CMD_MOTOR2_FWD, val);
  }
  else
  {
    SendMotorPacket(SABERTOOTH_ADDR, SABERTOOTH_CMD_MOTOR2_REV, val);
  }
}


void setRightMotorPower(float power)
{
  if (power > 100.0)
    power = 100.0;
    
  if (power < -100.0)
    power = -100.0;
    
  char val = map(abs(power), 0, 100, 0, 127); 
  if (power >= 0.0)
  {
    SendMotorPacket(SABERTOOTH_ADDR, SABERTOOTH_CMD_MOTOR1_FWD, val);
  }
  else
  {
    SendMotorPacket(SABERTOOTH_ADDR, SABERTOOTH_CMD_MOTOR1_REV, val);
  }
}




void MotorControl_cb( const geometry_msgs::Twist& msg)
{
  motorLeftPower = 10.0 * msg.linear.x - msg.angular.z * 50 / 2.0f;
  motorRightPower = 10.0 * msg.linear.x + msg.angular.z * 50 / 2.0f; 
  //vth = msg.angular.z;
  setLeftMotorPower(motorLeftPower);
  setRightMotorPower(motorRightPower);  
  
  
  /*char output[80];
  
  sprintf(output,"Updating Motor: %f %f *** %f %f",msg.linear.x,  msg.angular.z, motorLeftPower,motorRightPower);

  debug.data = output;
  pubDebug.publish( &debug );*/
}

void printDebug()
{
  char output[80];
  
  sprintf(output,"%i-%i-%i  %i:%i:%i ** %f - %f",GPS.month, GPS.day, GPS.year, GPS.hour, GPS.minute, GPS.seconds,motorLeftPower,motorRightPower);

  debug.data = output;
  pubDebug.publish( &debug );
}

void checkTimers()
{
  publishGPS();

  if (millis() - timerEncoder > UPDATE_RATE_ENCODER)
  {
   // updateEncoders();
  }
  
  if (millis() - timerIMU > UPDATE_RATE_IMU)
  {
   timerIMU = millis();
   
   publishIMU();
  }

  /*if (millis() - timerOdom > UPDATE_RATE_ODOM)
  {
    timerOdom = millis(); 
    publishOdom();  
  }*/

  if (millis() - timerTF > UPDATE_RATE_TF)
  {
   timerTF = millis();
   publishTF();
  }

  if (millis() - timerDebug > UPDATE_RATE_DEBUG)
  {
   timerDebug = millis();
   printDebug();
  }
  
}

//ros::Subscriber<std_msgs::Float32> subMotorLeft("motorLeft", LeftMotor_cb);
//ros::Subscriber<std_msgs::Float32> subMotorRight("motorRight", RightMotor_cb);
//ros::Subscriber<geometry_msgs::Twist> subVel("cmd_vel", MotorControl_cb);
//ros::Subscriber<geometry_msgs::Vector3> subWheel("wheel_encoder", WheelCallback,100);


void setup() {
  // put your setup code here, to run once:
  Wire.begin(); // join i2c bus (address optional for master)
  delayMicroseconds(10000); //wait for motor driver to initialization
  SabertoothSerial.begin(9600);
 
  current_time = millis();
  last_time = millis();
  nh.initNode();
  broadcaster.init(nh);
  //nh.advertise(pubOdom);
  nh.advertise(pubLWheel);
  nh.advertise(pubRWheel);
  
  nh.advertise(pubTimeReference);
  nh.advertise(pubNavData);
  nh.advertise(pubNavVel);
  nh.advertise(pubIMU);
  nh.advertise(pubDebug);
  
  //nh.subscribe(subMotorLeft);
  //nh.subscribe(subMotorRight);
  //nh.subscribe(subVel);
  //nh.subscribe(subWheel);

  
  InitializeGPS();
  InitializeIMU();
}

void publishOdom()
{
  double dt = (millis()  - last_time)/1000.0;
  last_time = millis();

  //double r = (vx * base_width) / (vy - vx); 
  //vth = vx / r;
  
  double delta_x = (vx * cos(th) - vy * sin(th)) * dt;
  double delta_y = (vx * sin(th) + vy * cos(th)) * dt;
  double delta_th = vth * dt;

   x += delta_x;
   y += delta_y;
   th += delta_th;
  //geometry_msgs::Quaternion odom_quat = tf::createQuaternionFromYaw(th);
  //imu::Quaternion odom_quat = bno.getQuat();

  odomData.header.stamp = nh.now();
  odomData.header.frame_id = odom;
   
  //set the position
  odomData.pose.pose.position.x = x;
  odomData.pose.pose.position.y = y;
  odomData.pose.pose.position.z = 0.0;
  //odomData.pose.pose.orientation = odom_quat;

  //odomData.pose.pose.orientation.x = odom_quat.x();  
  //odomData.pose.pose.orientation.y = odom_quat.y();  
  //odomData.pose.pose.orientation.z = odom_quat.z();  
  //odomData.pose.pose.orientation.w = odom_quat.w(); 
   
  //set the velocity
  odomData.child_frame_id = base_link;
  odomData.twist.twist.linear.x = vx;
  odomData.twist.twist.linear.y = vy;
  odomData.twist.twist.angular.z = vth;
   
  //publish the message
  //pubOdom.publish(&odomData);
}

void publishTF()
{

  tfBaseOdom.header.frame_id = odom;
  tfBaseOdom.child_frame_id = base_link;
  
  tfBaseOdom.transform.translation.x = x; 
  tfBaseOdom.transform.translation.y = y; 
  tfBaseOdom.transform.translation.z = 0; 
  
  //tfBaseOdom.transform.rotation.x = odom_quat.x();  
  //tfBaseOdom.transform.rotation.y = odom_quat.y();  
  //tfBaseOdom.transform.rotation.z = odom_quat.z();  
  //tfBaseOdom.transform.rotation.w = odom_quat.w();  
  
  tfBaseOdom.header.stamp = nh.now();
  broadcaster.sendTransform(tfBaseOdom);


  
  /*tfBaseLaser.header.frame_id = base_link;
  tfBaseLaser.child_frame_id = laser;
  tfBaseLaser.transform.translation.z = 0.1; 
  tfBaseLaser.transform.rotation.x = 0.0;
  tfBaseLaser.transform.rotation.y = 0.0; 
  tfBaseLaser.transform.rotation.z = 0.0; 
  tfBaseLaser.transform.rotation.w = 1.0;  
  tfBaseLaser.header.stamp = nh.now();
  broadcaster.sendTransform(tfBaseLaser);*/
}

void publishIMU()
{
  imu::Vector<3> accel = bno.getVector(Adafruit_BNO055::VECTOR_ACCELEROMETER);
  imu::Vector<3> gyro = bno.getVector(Adafruit_BNO055::VECTOR_GYROSCOPE );
  imu::Quaternion quat = bno.getQuat();
  //int8_t temp = bno.getTemp();

  imuMsg.linear_acceleration.x = accel.x();
  imuMsg.linear_acceleration.y = accel.y();
  imuMsg.linear_acceleration.z = accel.z();

  imuMsg.angular_velocity.x = gyro.x();
  imuMsg.angular_velocity.y = gyro.y();
  imuMsg.angular_velocity.z = gyro.z();

  imuMsg.orientation.x = quat.x();
  imuMsg.orientation.y = quat.y();
  imuMsg.orientation.z = quat.z();
  imuMsg.orientation.w = quat.w();
  char id[] = "imu_link";
  imuMsg.header.frame_id = id;
  imuMsg.header.stamp=nh.now();
  imuMsg.header.seq = seq;
  seq = seq + 1;
  pubIMU.publish(&imuMsg);
}

void updateEncoders()
{

  current_time_encoder =  millis();

  long countLeft = -encoderLR.read();
  long countRight = encoderRR.read();

  //encoderLR.write(0);
  //encoderRR.write(0);
  
  deltaLeft = countLeft - previousLeftEncoderCount;
  deltaRight = countRight - previousRightEncoderCount;
 
  float deltaT = (current_time_encoder - last_time_encoder) / 1000.0;

  vx = deltaLeft * DISTANCE_PER_COUNT / deltaT;
  vy = deltaRight * DISTANCE_PER_COUNT / deltaT; 
  
  

  previousLeftEncoderCount = countLeft;
  previousRightEncoderCount = countRight;
  last_time_encoder = current_time_encoder;
}

void loop() {
  //updateEncoders();
  
  nh.spinOnce();
  checkTimers();
  delay(1);
}
